---
author: chapter09
comments: true
date: 2011-10-22 11:33:51+00:00
layout: post
slug: '%e4%bb%8epcap_loop%e5%87%bd%e6%95%b0%e6%9d%a5%e7%90%86%e8%a7%a3%e5%9b%9e%e8%b0%83%e5%87%bd%e6%95%b0'
title: 从pcap_loop函数来理解回调函数
wordpress_id: 211
categories:
- Tech
tags:
- jpcap
- libpcap
- pcap_joop
---

在读老师给的代码DetectPortscan.c中：

pcap_loop(phandle,-1,pcap_callback	,NULL);

看到了pcap_callback回调函数的使用，具体pcap_callback函数如下：
<!-- more -->

[code lang="c"]
void pcap_callback(u_char *user,const struct pcap_pkthdr *header,const u_char *pkt_data) {
	int existflag;
//  	int count;
  	IPHEADER *ip_header;
  	TCPHEADER *tcp_header;
	struct timeval current_tv;
	time_t current_time;
	gettimeofday(¤t_tv,NULL);
	current_time = current_tv.tv_sec;
  	if(header-&gt;len &gt;= 14)
    	ip_header=(IPHEADER*)(pkt_data+14);
	else
		return;
  	if(ip_header-&gt;proto == 6){
    	if(header-&gt;len &gt;= 34)
      	tcp_header=(TCPHEADER*)(pkt_data+34);
		else
			return;
		if ((tcp_header-&gt;syn == 0) || ((tcp_header-&gt;ack == 1)))
			return;
    	DetectedHost *phost=(DetectedHost*)malloc(sizeof(DetectedHost));
    	bzero(phost,sizeof(DetectedHost));
   	strncpy(phost-&gt;src_ip,ip_header-&gt;sourceIP,4);
    	strncpy(phost-&gt;dest_ip,ip_header-&gt;destIP,4);
	    	phost-&gt;port_list[0] = tcp_header-&gt;dest_port;
    	phost-&gt;time_list[0] = current_time;
		existflag = 0;
    	DetectedHost *p= pHostlistHeader;
		while(p != NULL){
			int validnum_scanedport = updatehostinfo(p,phost,&amp;existflag);
			DetectedHost *tmphost = NULL;
     		if(validnum_scanedport == 0)
        		tmphost = p;
			else if(validnum_scanedport &gt;= para.port_num){
				tmphost = p;
				output_alert(p);
			}
			p = p-&gt;next;
			if (tmphost) delete_host(tmphost);
    		}
		if (existflag == 0)
			add_host(phost);
		else
			free(phost);
	}
}[/code]
于是希望通过pcap_loop函数了解回调用法。从libpcap的源代码中，pcap.c文件中可以找到pcap_loop的定义：
[code lang="C"]
int pcap_loop(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
{
	register int n;

	for (;;) {
		if (p-&gt;sf.rfile != NULL) {
			/*
			 * 0 means EOF, so don't loop if we get 0.
			 */
			n = pcap_offline_read(p, cnt, callback, user);
		} else {
			/*
			 * XXX keep reading until we get something
			 * (or an error occurs)
			 */
			do {
				n = p-&gt;read_op(p, cnt, callback, user);
			} while (n == 0);
		}
		if (n &lt;= 0) 			return (n); 		if (cnt &gt; 0) {
			cnt -= n;
			if (cnt &lt;= 0)
				return (0);
		}
	}
}
[/code]
然后继续读函数pcap_offline_read，如下：
[code lang="C"]
int pcap_offline_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
{
	struct bpf_insn *fcode;
	int status = 0;
	int n = 0;
	u_char *data;

	while (status == 0) {
		struct pcap_pkthdr h;

		/*
		 * Has "pcap_breakloop()" been called?
		 * If so, return immediately - if we haven't read any
		 * packets, clear the flag and return -2 to indicate
		 * that we were told to break out of the loop, otherwise
		 * leave the flag set, so that the *next* call will break
		 * out of the loop without having read any packets, and
		 * return the number of packets we've processed so far.
		 */
		if (p-&gt;break_loop) {
			if (n == 0) {
				p-&gt;break_loop = 0;
				return (-2);
			} else
				return (n);
		}

		status = p-&gt;sf.next_packet_op(p, &amp;h, &amp;data);
		if (status) {
			if (status == 1)
				return (0);
			return (status);
		}

		if ((fcode = p-&gt;fcode.bf_insns) == NULL ||
		    bpf_filter(fcode, p-&gt;buffer, h.len, h.caplen)) {
			(*callback)(user, &amp;h, data);
			if (++n &gt;= cnt &amp;&amp; cnt &gt; 0)
				break;
		}
	}
	/*XXX this breaks semantics tcpslice expects */
	return (n);
}[/code]


有一行(*callback)(user, &h, data)，这即是调用回调函数，通过指针指向回调函数名传入参数。再来看看回调函数的概念图：



![](http://www-128.ibm.com/developerworks/cn/linux/l-callback/images/image001.gif)这样就理解通了。


> 图片转载自[http://blog.chinaunix.net/space.php?uid=2630593&do=blog&id=2138414](http://blog.chinaunix.net/space.php?uid=2630593&do=blog&id=2138414)
