---
author: chapter09
comments: true
date: 2012-06-11 05:13:21+00:00
layout: post
slug: '%e9%94%99%e6%80%aaeventlet%e4%ba%86'
title: 错怪eventlet了
wordpress_id: 750
categories:
- Tech
---

用eventlet来实现HTTP request的高并发

[eventlet介绍]

引用[http://gfnpad.blogspot.jp/2010/05/eventlet.html](http://gfnpad.blogspot.jp/2010/05/eventlet.html)

[Eventlet](http://eventlet.net/)是由第二人生([Secondlife](http://secondlife.com/))开源的高度伸缩性的Python网络编程库.

根据官方介绍大致特性如下:



	
  * 非阻塞I/O模型

	
  * 协程(Coroutines)使得开发者可以采用阻塞式的开发风格,却能够实现非阻塞I/O的效果

	
  * 隐式事件调度,使得可以在Python解释器或者应用程序的某一部分去使用Eventlet


关于协程,大致可以理解成允许子程序可以多次暂停和恢复执行,是实现多任务的一种有效手段,具体见[这里](http://en.wikipedia.org/wiki/Coroutine#cite_note-0)
在Python的世界里,实现了nonblocking I/O的产品并不算少.比如内置的Asyncore和著名的Twisted.相比之下,Eventlet是更容易上手和使用的。

举个例子

[code lang="python"]
import eventlet
pool = eventlet.GreenPool()
while True:    pool.spawn(func,args)
[/code]


上面这段代码,几乎就是使用eventlet的范式：



	
  * GreenPool 用来实现协程,保证并行;

	
  * Spawn     用来调用相应的函数,完成具体业务.


每个func之间切换，实施“你运行一会、我运行一会”，并且在进行切换时必须指定何时切换以及切换到哪，当出现阻塞时，就显式切换到另一 段没有被阻塞的代码段执行，直到原先的阻塞状况消失以后，再人工切换回原来的代码段继续处理.

[错误]

我为了测试eventlet的并发性，在func中加入了time.sleep，并启动多个greenThread来执行func，发现每一个greenThread是one by one执行的。然后我就认为这并发性糊涂掉了。

但是经同事指出，应该用eventlet.sleep，因为实际上整个eventlet 的Pool是跑在一个线程上的，因此time.sleep将会把eventlet给整个sleep掉

改用eventlet.sleep后，效果不错




