---
author: chapter09
comments: true
date: 2011-06-29 19:09:20+00:00
layout: post
slug: kernel%e9%98%85%e8%af%bb%e7%96%91%e9%97%ae
title: Kernel阅读疑问
wordpress_id: 81
categories:
- kernel
tags:
- Kernel
- Linux
---


	
  * list_head在哪里初始化一般？




	
  * sched_group是什么？增加的find_busiest_group意义


今天看到fudan_abc的《Linux内核修炼之道》，在讲到CFS时谈到了CFS引入的组调度，有一个task_group的结构。即将进程编为多个进程组。看到有博客提到

<!-- more -->



> **Linux将所有同一级别的cpu归为一个“调度组”，然后将同一级别的所有的调度组组成一个“调度域”**

——from [http://blog.csdn.net/dog250/archive/2011/06/11/6538240.aspx](http://blog.csdn.net/dog250/archive/2011/06/11/6538240.aspx)






	
  * 中断的具体实现，CPU对中断的操作中仍存在轮询？


这个问题跟3feng讨论后，他认为CPU仍然需要轮询，只不过对中断控制器的轮询，频率不如直接对设备轮询高，而且因为不需要深入到设备层，因此效率提高。

我认为中断机制的优越性在于能让事件的发生者主动通知CPU，而不需要CPU轮询。比如我的中断控制器可以直接调用schedule()进行进程调度，如果CPU这时候有进程正在运行，同时在没有设置禁止中断的标志下将被强制进行调度，这个过程CPU不需要轮询能够完成。

今天跟小超哥聊这一点，小超哥说，实际上，中断最底层是通过电平实现，由CPU专门的中断管脚接受相应电平后，CPU进入中断的工作模式。这样就不需要存在轮询了。而类似于轮询的逻辑由电路实现了，在代码层看不到。

我希望能深入到内核中探究中断实现细节，这个问题保留。



<未完待续>




